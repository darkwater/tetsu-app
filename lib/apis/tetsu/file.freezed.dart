// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'file.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

TetsuFile _$TetsuFileFromJson(Map<String, dynamic> json) {
  return _TetsuFile.fromJson(json);
}

/// @nodoc
mixin _$TetsuFile {
  String get path => throw _privateConstructorUsedError;
  int get fid => throw _privateConstructorUsedError;
  int get aid => throw _privateConstructorUsedError;
  int get eid => throw _privateConstructorUsedError;
  int get gid => throw _privateConstructorUsedError;
  int get state => throw _privateConstructorUsedError;
  int get size => throw _privateConstructorUsedError;
  String get ed2k => throw _privateConstructorUsedError;
  String get colourDepth => throw _privateConstructorUsedError;
  String get quality => throw _privateConstructorUsedError;
  String get source => throw _privateConstructorUsedError;
  List<String> get audioCodecList => throw _privateConstructorUsedError;
  List<int> get audioBitrateList => throw _privateConstructorUsedError;
  List<String> get videoCodec => throw _privateConstructorUsedError;
  List<String> get videoBitrate => throw _privateConstructorUsedError;
  List<String> get videoResolution => throw _privateConstructorUsedError;
  String get dubLanguage => throw _privateConstructorUsedError;
  String get subLanguage => throw _privateConstructorUsedError;
  int get lengthInSeconds => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  DateTime get airedDate => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TetsuFileCopyWith<TetsuFile> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TetsuFileCopyWith<$Res> {
  factory $TetsuFileCopyWith(TetsuFile value, $Res Function(TetsuFile) then) =
      _$TetsuFileCopyWithImpl<$Res, TetsuFile>;
  @useResult
  $Res call(
      {String path,
      int fid,
      int aid,
      int eid,
      int gid,
      int state,
      int size,
      String ed2k,
      String colourDepth,
      String quality,
      String source,
      List<String> audioCodecList,
      List<int> audioBitrateList,
      List<String> videoCodec,
      List<String> videoBitrate,
      List<String> videoResolution,
      String dubLanguage,
      String subLanguage,
      int lengthInSeconds,
      String description,
      DateTime airedDate});
}

/// @nodoc
class _$TetsuFileCopyWithImpl<$Res, $Val extends TetsuFile>
    implements $TetsuFileCopyWith<$Res> {
  _$TetsuFileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? fid = null,
    Object? aid = null,
    Object? eid = null,
    Object? gid = null,
    Object? state = null,
    Object? size = null,
    Object? ed2k = null,
    Object? colourDepth = null,
    Object? quality = null,
    Object? source = null,
    Object? audioCodecList = null,
    Object? audioBitrateList = null,
    Object? videoCodec = null,
    Object? videoBitrate = null,
    Object? videoResolution = null,
    Object? dubLanguage = null,
    Object? subLanguage = null,
    Object? lengthInSeconds = null,
    Object? description = null,
    Object? airedDate = null,
  }) {
    return _then(_value.copyWith(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      fid: null == fid
          ? _value.fid
          : fid // ignore: cast_nullable_to_non_nullable
              as int,
      aid: null == aid
          ? _value.aid
          : aid // ignore: cast_nullable_to_non_nullable
              as int,
      eid: null == eid
          ? _value.eid
          : eid // ignore: cast_nullable_to_non_nullable
              as int,
      gid: null == gid
          ? _value.gid
          : gid // ignore: cast_nullable_to_non_nullable
              as int,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as int,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      ed2k: null == ed2k
          ? _value.ed2k
          : ed2k // ignore: cast_nullable_to_non_nullable
              as String,
      colourDepth: null == colourDepth
          ? _value.colourDepth
          : colourDepth // ignore: cast_nullable_to_non_nullable
              as String,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as String,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String,
      audioCodecList: null == audioCodecList
          ? _value.audioCodecList
          : audioCodecList // ignore: cast_nullable_to_non_nullable
              as List<String>,
      audioBitrateList: null == audioBitrateList
          ? _value.audioBitrateList
          : audioBitrateList // ignore: cast_nullable_to_non_nullable
              as List<int>,
      videoCodec: null == videoCodec
          ? _value.videoCodec
          : videoCodec // ignore: cast_nullable_to_non_nullable
              as List<String>,
      videoBitrate: null == videoBitrate
          ? _value.videoBitrate
          : videoBitrate // ignore: cast_nullable_to_non_nullable
              as List<String>,
      videoResolution: null == videoResolution
          ? _value.videoResolution
          : videoResolution // ignore: cast_nullable_to_non_nullable
              as List<String>,
      dubLanguage: null == dubLanguage
          ? _value.dubLanguage
          : dubLanguage // ignore: cast_nullable_to_non_nullable
              as String,
      subLanguage: null == subLanguage
          ? _value.subLanguage
          : subLanguage // ignore: cast_nullable_to_non_nullable
              as String,
      lengthInSeconds: null == lengthInSeconds
          ? _value.lengthInSeconds
          : lengthInSeconds // ignore: cast_nullable_to_non_nullable
              as int,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      airedDate: null == airedDate
          ? _value.airedDate
          : airedDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TetsuFileCopyWith<$Res> implements $TetsuFileCopyWith<$Res> {
  factory _$$_TetsuFileCopyWith(
          _$_TetsuFile value, $Res Function(_$_TetsuFile) then) =
      __$$_TetsuFileCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String path,
      int fid,
      int aid,
      int eid,
      int gid,
      int state,
      int size,
      String ed2k,
      String colourDepth,
      String quality,
      String source,
      List<String> audioCodecList,
      List<int> audioBitrateList,
      List<String> videoCodec,
      List<String> videoBitrate,
      List<String> videoResolution,
      String dubLanguage,
      String subLanguage,
      int lengthInSeconds,
      String description,
      DateTime airedDate});
}

/// @nodoc
class __$$_TetsuFileCopyWithImpl<$Res>
    extends _$TetsuFileCopyWithImpl<$Res, _$_TetsuFile>
    implements _$$_TetsuFileCopyWith<$Res> {
  __$$_TetsuFileCopyWithImpl(
      _$_TetsuFile _value, $Res Function(_$_TetsuFile) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? fid = null,
    Object? aid = null,
    Object? eid = null,
    Object? gid = null,
    Object? state = null,
    Object? size = null,
    Object? ed2k = null,
    Object? colourDepth = null,
    Object? quality = null,
    Object? source = null,
    Object? audioCodecList = null,
    Object? audioBitrateList = null,
    Object? videoCodec = null,
    Object? videoBitrate = null,
    Object? videoResolution = null,
    Object? dubLanguage = null,
    Object? subLanguage = null,
    Object? lengthInSeconds = null,
    Object? description = null,
    Object? airedDate = null,
  }) {
    return _then(_$_TetsuFile(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      fid: null == fid
          ? _value.fid
          : fid // ignore: cast_nullable_to_non_nullable
              as int,
      aid: null == aid
          ? _value.aid
          : aid // ignore: cast_nullable_to_non_nullable
              as int,
      eid: null == eid
          ? _value.eid
          : eid // ignore: cast_nullable_to_non_nullable
              as int,
      gid: null == gid
          ? _value.gid
          : gid // ignore: cast_nullable_to_non_nullable
              as int,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as int,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      ed2k: null == ed2k
          ? _value.ed2k
          : ed2k // ignore: cast_nullable_to_non_nullable
              as String,
      colourDepth: null == colourDepth
          ? _value.colourDepth
          : colourDepth // ignore: cast_nullable_to_non_nullable
              as String,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as String,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String,
      audioCodecList: null == audioCodecList
          ? _value._audioCodecList
          : audioCodecList // ignore: cast_nullable_to_non_nullable
              as List<String>,
      audioBitrateList: null == audioBitrateList
          ? _value._audioBitrateList
          : audioBitrateList // ignore: cast_nullable_to_non_nullable
              as List<int>,
      videoCodec: null == videoCodec
          ? _value._videoCodec
          : videoCodec // ignore: cast_nullable_to_non_nullable
              as List<String>,
      videoBitrate: null == videoBitrate
          ? _value._videoBitrate
          : videoBitrate // ignore: cast_nullable_to_non_nullable
              as List<String>,
      videoResolution: null == videoResolution
          ? _value._videoResolution
          : videoResolution // ignore: cast_nullable_to_non_nullable
              as List<String>,
      dubLanguage: null == dubLanguage
          ? _value.dubLanguage
          : dubLanguage // ignore: cast_nullable_to_non_nullable
              as String,
      subLanguage: null == subLanguage
          ? _value.subLanguage
          : subLanguage // ignore: cast_nullable_to_non_nullable
              as String,
      lengthInSeconds: null == lengthInSeconds
          ? _value.lengthInSeconds
          : lengthInSeconds // ignore: cast_nullable_to_non_nullable
              as int,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      airedDate: null == airedDate
          ? _value.airedDate
          : airedDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.snake)
class _$_TetsuFile extends _TetsuFile {
  const _$_TetsuFile(
      {required this.path,
      required this.fid,
      required this.aid,
      required this.eid,
      required this.gid,
      required this.state,
      required this.size,
      required this.ed2k,
      required this.colourDepth,
      required this.quality,
      required this.source,
      required final List<String> audioCodecList,
      required final List<int> audioBitrateList,
      required final List<String> videoCodec,
      required final List<String> videoBitrate,
      required final List<String> videoResolution,
      required this.dubLanguage,
      required this.subLanguage,
      required this.lengthInSeconds,
      required this.description,
      required this.airedDate})
      : _audioCodecList = audioCodecList,
        _audioBitrateList = audioBitrateList,
        _videoCodec = videoCodec,
        _videoBitrate = videoBitrate,
        _videoResolution = videoResolution,
        super._();

  factory _$_TetsuFile.fromJson(Map<String, dynamic> json) =>
      _$$_TetsuFileFromJson(json);

  @override
  final String path;
  @override
  final int fid;
  @override
  final int aid;
  @override
  final int eid;
  @override
  final int gid;
  @override
  final int state;
  @override
  final int size;
  @override
  final String ed2k;
  @override
  final String colourDepth;
  @override
  final String quality;
  @override
  final String source;
  final List<String> _audioCodecList;
  @override
  List<String> get audioCodecList {
    if (_audioCodecList is EqualUnmodifiableListView) return _audioCodecList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_audioCodecList);
  }

  final List<int> _audioBitrateList;
  @override
  List<int> get audioBitrateList {
    if (_audioBitrateList is EqualUnmodifiableListView)
      return _audioBitrateList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_audioBitrateList);
  }

  final List<String> _videoCodec;
  @override
  List<String> get videoCodec {
    if (_videoCodec is EqualUnmodifiableListView) return _videoCodec;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_videoCodec);
  }

  final List<String> _videoBitrate;
  @override
  List<String> get videoBitrate {
    if (_videoBitrate is EqualUnmodifiableListView) return _videoBitrate;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_videoBitrate);
  }

  final List<String> _videoResolution;
  @override
  List<String> get videoResolution {
    if (_videoResolution is EqualUnmodifiableListView) return _videoResolution;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_videoResolution);
  }

  @override
  final String dubLanguage;
  @override
  final String subLanguage;
  @override
  final int lengthInSeconds;
  @override
  final String description;
  @override
  final DateTime airedDate;

  @override
  String toString() {
    return 'TetsuFile(path: $path, fid: $fid, aid: $aid, eid: $eid, gid: $gid, state: $state, size: $size, ed2k: $ed2k, colourDepth: $colourDepth, quality: $quality, source: $source, audioCodecList: $audioCodecList, audioBitrateList: $audioBitrateList, videoCodec: $videoCodec, videoBitrate: $videoBitrate, videoResolution: $videoResolution, dubLanguage: $dubLanguage, subLanguage: $subLanguage, lengthInSeconds: $lengthInSeconds, description: $description, airedDate: $airedDate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TetsuFile &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.fid, fid) || other.fid == fid) &&
            (identical(other.aid, aid) || other.aid == aid) &&
            (identical(other.eid, eid) || other.eid == eid) &&
            (identical(other.gid, gid) || other.gid == gid) &&
            (identical(other.state, state) || other.state == state) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.ed2k, ed2k) || other.ed2k == ed2k) &&
            (identical(other.colourDepth, colourDepth) ||
                other.colourDepth == colourDepth) &&
            (identical(other.quality, quality) || other.quality == quality) &&
            (identical(other.source, source) || other.source == source) &&
            const DeepCollectionEquality()
                .equals(other._audioCodecList, _audioCodecList) &&
            const DeepCollectionEquality()
                .equals(other._audioBitrateList, _audioBitrateList) &&
            const DeepCollectionEquality()
                .equals(other._videoCodec, _videoCodec) &&
            const DeepCollectionEquality()
                .equals(other._videoBitrate, _videoBitrate) &&
            const DeepCollectionEquality()
                .equals(other._videoResolution, _videoResolution) &&
            (identical(other.dubLanguage, dubLanguage) ||
                other.dubLanguage == dubLanguage) &&
            (identical(other.subLanguage, subLanguage) ||
                other.subLanguage == subLanguage) &&
            (identical(other.lengthInSeconds, lengthInSeconds) ||
                other.lengthInSeconds == lengthInSeconds) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.airedDate, airedDate) ||
                other.airedDate == airedDate));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        path,
        fid,
        aid,
        eid,
        gid,
        state,
        size,
        ed2k,
        colourDepth,
        quality,
        source,
        const DeepCollectionEquality().hash(_audioCodecList),
        const DeepCollectionEquality().hash(_audioBitrateList),
        const DeepCollectionEquality().hash(_videoCodec),
        const DeepCollectionEquality().hash(_videoBitrate),
        const DeepCollectionEquality().hash(_videoResolution),
        dubLanguage,
        subLanguage,
        lengthInSeconds,
        description,
        airedDate
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TetsuFileCopyWith<_$_TetsuFile> get copyWith =>
      __$$_TetsuFileCopyWithImpl<_$_TetsuFile>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TetsuFileToJson(
      this,
    );
  }
}

abstract class _TetsuFile extends TetsuFile {
  const factory _TetsuFile(
      {required final String path,
      required final int fid,
      required final int aid,
      required final int eid,
      required final int gid,
      required final int state,
      required final int size,
      required final String ed2k,
      required final String colourDepth,
      required final String quality,
      required final String source,
      required final List<String> audioCodecList,
      required final List<int> audioBitrateList,
      required final List<String> videoCodec,
      required final List<String> videoBitrate,
      required final List<String> videoResolution,
      required final String dubLanguage,
      required final String subLanguage,
      required final int lengthInSeconds,
      required final String description,
      required final DateTime airedDate}) = _$_TetsuFile;
  const _TetsuFile._() : super._();

  factory _TetsuFile.fromJson(Map<String, dynamic> json) =
      _$_TetsuFile.fromJson;

  @override
  String get path;
  @override
  int get fid;
  @override
  int get aid;
  @override
  int get eid;
  @override
  int get gid;
  @override
  int get state;
  @override
  int get size;
  @override
  String get ed2k;
  @override
  String get colourDepth;
  @override
  String get quality;
  @override
  String get source;
  @override
  List<String> get audioCodecList;
  @override
  List<int> get audioBitrateList;
  @override
  List<String> get videoCodec;
  @override
  List<String> get videoBitrate;
  @override
  List<String> get videoResolution;
  @override
  String get dubLanguage;
  @override
  String get subLanguage;
  @override
  int get lengthInSeconds;
  @override
  String get description;
  @override
  DateTime get airedDate;
  @override
  @JsonKey(ignore: true)
  _$$_TetsuFileCopyWith<_$_TetsuFile> get copyWith =>
      throw _privateConstructorUsedError;
}
